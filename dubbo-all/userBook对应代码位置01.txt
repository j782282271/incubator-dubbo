6.16/17）泛化引用与泛化实现
   1） provider泛化实现：
    <bean id="genService" class="com.alibaba.dubbo.demo.provider.GenService"/>
    <!--因为是泛化引用此处接口可以随便写，即使不存在，consumer的refence也是可以随便写该参数，不过要与provider这里的相同-->
    <dubbo:service interface="a.a.a" ref="genService"/>
    
    public class GenService implements GenericService {
    @Override
    public Object $invoke(String method, String[] parameterTypes, Object[] args) throws GenericException {
        if (method.equals("sayHello")) {
            return "hello" + args[0];
        }
        return "null";
     }
   }
   
   2）consumer泛化引用：
   <!--因为是泛化引用此处接口可以随便写，即使不存在，provider的service也是可以随便写该参数，不过要与consumer这里的相同-->
   <dubbo:reference id="genService" interface="a.a.a" generic="true"/>
   GenericService genService = (GenericService) context.getBean("genService"); // get remote service proxy
   Object result = genService.$invoke("sayHello", new String[]{"java.lang.String"}, new Object[]{"World"});
   System.out.println(result); // get result
   
   3）代码：相关wiki：
   provider：会将a.a.a作为ServiceConfig类的interfaceName属性
     ServiceConfig会判断ref的父类是否为GenericService，如果是，将GenericService作为interfaceClass，而不是a.a.a的class，因为a.a.a可能不存在java类
     创建要暴露的url的时候会将a.a.a作为path，generic=true作为一个参数暴露服务
   consumer:同上，会将a.a.a作为ReferenceConfig类的interfaceName属性
     referenceConfig会解析generic参数，发现为true,设置interfaceClass属性为GenericService
     consumer在调用$invoke方法时和调用其他方法一样，都会把方法名、参数类型、参数序列化用于底层传输
     GenericFilter for provider将map变为bean、GenericFilter for consumer将bean变为map


6.18）回声测试 EchoService
      provider EchoFilter provider拦截到该方法的调用，直接原样返回请求参数
      consumer AbstractProxyFactory.getProxy的时候让每个refBean都继自EchoService

6.19）上下文信息
    ConsumerContextFilter for consumer对 RpcContext进行设置
    ContextFilter  for provider对 RpcContext进行设置，底层invoker调用完毕后会清空ThreadLocal
    
6.20）隐式参数，用于框架集成，不建议常规业务使用
   可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费⽅和提供⽅之间进⾏参数的隐式传递。
   
6.21）consumer异步调用  (2.7.x版本有变化，最新wiki：http://dubbo.apache.org/zh-cn/docs/user/demos/async-call.html)
      下面介绍2.7.x以前的使用方式
      reference配置async=true参数，则不能使用同步方式了即返回结果为null，可以使用异步方式：
      <dubbo:reference id="fooService" interface="com.alibaba.foo.FooService">
      <dubbo:method name="findFoo" async="true" />
      </dubbo:reference>
     具体使用见文档。
     代码：DubboInvoker.doInvoke方法boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);
     如果是异步，直接返回空结果：new RpcResult();然后将future放到ThreadLocal的RpcContext
     关于sent参数，NettyChannel.send(Object message, boolean sent)中这一行有体现：
     ChannelFuture future = channel.write(message);是否等待写到channel中完毕
     
6.21.1）provider端异步执行，2.6.x还不支持
    Provider端异步执行将阻塞的业务从Dubbo内部线程池切换到业务自定义线程，避免Dubbo线程池的过度占用，
    有助于避免不同服务间的互相影响。异步执行无益于节省资源或提升RPC响应性能，因为如果业务执行需要阻塞，
    则始终还是要有线程来负责执行。  

6.22）本地调用 injvm
     定义 injvm 协议:<dubbo:protocol name="injvm" />
		 设置默认协议:<dubbo:provider protocol="injvm" />
		 设置服务协议:<dubbo:service protocol="injvm" />
		 优先使用 injvm:<dubbo:consumer injvm="true" .../>、<dubbo:provider injvm="true" .../>
		 或<dubbo:reference injvm="true" .../>、<dubbo:service injvm="true" .../>
     如果希望引用远程服务可以使用一下配置强制引用远程服务：<dubbo:reference ... scope="remote" />
     代码：InjvmProtocol.isInjvmRefer判断是否是本地引用
     
6.23）参数回调：consumer向provider注册监听事件，等待provider回调，就像zk监听节点一样等待zkserver的回调通知
      
6.24）事件通知
6.25）本地存根     
     
   